import time, subprocess
import lr_inverter
from Circle_expansion_2LMMCC import *

import sys

# ### Parameter for Dataset ###
# value_file = "/Module_3/Inferring_Compounds/sample_instance/IhcLiq_values(value_file).txt" # The observed value of the dataset that you use to construct the prediction function
# original_data_file = "/Module_3/Inferring_Compounds/sample_instance/IhcLiq_C_O_N_H_desc(original_data_file).csv" # Feature vector of dataset
# fv_fringe_file = "/Module_3/Inferring_Compounds/sample_instance/IhcLiq_C_O_N_H_fringe(fv_fringe_file).txt" # The fringe file of dataset that generated by feature function.

# ### Parameter for Instance ###
# LR_file = "/Module_3/Inferring_Compounds/sample_instance/IhcLiq_LR(LR_file).txt" # The path of prediction function of hyperplane
# seed_tree_file = "/Module_3/Inferring_Compounds/sample_instance/IhcLiq_3_a0(seed_tree_file).txt" #The path of seed tree
# seed_tree_fringe_file = "/Module_3/Inferring_Compounds/sample_instance/IhcLiq_C_O_N_H_fringe(fv_fringe_file).txt" # The path of fringe file of seed tree

# ### Parameter for Output chemical graph ###
# instance_name = "IhcLiq_3_a0_ex" # Define the name of output chemical graph
# output_path = "" # Output inferred chemical graph
# value_of_var = "" #Used to output the solution values of MILP variables.

### Parameter for solver ###
CPLEX_path = "/Applications/CPLEX_Studio2211/cplex/bin/arm64_osx/cplex" #The path of MILP solver

#Macro
std_eps = 1e-5
solver_type = 1
CPLEX_TIMELIMIT = 600
CPLEX_msg = False

def main(argv):
    prop = argv[1]

    value_file = f"{prop}_values.txt"
    original_data_file = f"{prop}_desc.csv"
    fv_fringe_file = f"{prop}_fringe.txt"

    LR_file = f"{prop}_LR.txt"

    seed_tree_file = argv[2]
    seed_tree_fringe_file = argv[3]

    output_path = argv[4]
    instance_name = argv[5]

    value_of_var = "test.txt"

    target_value_lb = float(argv[6])
    target_value_ub = float(argv[7])

    MILP = pulp.LpProblem(name="MILP_1")
    start = time.time()
    set_Lambda = element_info()
    gamma_lf_ac = prepare_gamma_lf_ac(set_Lambda)

    (V_T, E_T, Vo, Vo_bar, Eo, Eo_bar, Eo_u, Eo_bar_u, Xi_T, Xi_u,
    Lambda, gammaInt_ac, gammaInt_ec, leaf_of_non_ring_node,
    N_T_v, val_a, mass_star_a, naInt_LB_a, naInt_UB_a,
    naEx_LB_a, naEx_UB_a, na_LB_a, na_UB_a, acLf_LB, acLf_UB,
    acInt_LB, acInt_UB, ecInt_LB, ecInt_UB, n_LB, n_UB, M1, epsilon1,
     n_int_LB, n_int_UB, M_ms, rho, Lambda_int) = read_seedgraph(seed_tree_file, gamma_lf_ac, set_Lambda)

    ksi_delta_r_mu = prepare_ksi_delta_r_mu0(Xi_T)

    fring_set, Lambda_ex, strF, _, _ = prepare_fringe_trees(seed_tree_fringe_file, Lambda)
    index_set = read_fringe_tree(fv_fringe_file, strF)

    (F_u, F_t, alpha_r_phi, valex_F_phi,eledeg_F_phi, n_a_phi,deg_H_bar_phi,
     ms_F_phi, ht_F_phi, n_H_bar_phi, ac_lf_gamma_phi) = function_of_fringe(fring_set,V_T,gamma_lf_ac,Lambda,set_Lambda)

    #3.1
    y_u_mu, z_u_r, x_u_ksi_mu0_delta, x_u_ksi, cc_ksi, MILP = assigning_cycles_to_ring_nodes(Vo,
            M1,
            epsilon1,
            Xi_T,
            Xi_u,
            ksi_delta_r_mu,
            #model
            MILP)
    #3.2
    e_u_i, xEdge_u_e_v, xNode_u_ePrime_mu, MILP = attaching_two_cycles(
            Xi_u,
            x_u_ksi,
            Vo,
            Eo_u,
            Eo_bar_u,
            #model
            MILP)

    #3.3
    delta_F_u_mu_phi, delta_F_v_phi, fc_e_phi , rank, n_G, n_int, fc_phi, ac_lf_gamma, MILP = constraint_for_including_fringe_tree(rho,
            leaf_of_non_ring_node,
            ms_F_phi,
            ht_F_phi,
            n_H_bar_phi,
            ac_lf_gamma_phi,
            Vo,
            Vo_bar,
            x_u_ksi,
            y_u_mu,
            xEdge_u_e_v,
            Xi_T,
            Xi_u,
            Eo,
            Eo_u,
            F_u,
            F_t,
            n_LB,
            n_UB,
            n_int_LB,
            n_int_UB,
            gamma_lf_ac,
            acLf_LB,
            acLf_UB,
            MILP)

    #3.4
    (delta_Deg_u_mu_d, delta_Deg_v_d, deltaInt_Deg_u_mu_d,
    deltaInt_Deg_v_d, deg_d, degInt_d, deg_e_d, degInt_e_d,degEdge_u_e_mu_minus,degEdge_u_e_mu_plus, MILP) = descriptprs_for_the_number_of_specified_degree(deg_H_bar_phi,
            Vo,
            Vo_bar,
            Eo,
            Eo_u,
            Eo_bar_u,
            Xi_u,
            x_u_ksi,
            E_Cu_mu,
            N_T_v,
            F_u,
            xEdge_u_e_v,
            xNode_u_ePrime_mu,
            delta_F_v_phi,
            delta_F_u_mu_phi,
            MILP)

    #3.5
    beta_u_i, beta_e, delta_beta_u_i_m, delta_beta_e_m, bd_m, MILP = assigning_bond_multiplicity(Vo,
            E_T,
            Eo,
            Eo_u,
            Eo_bar, #list, Non ring edge
            xEdge_u_e_v,
            e_u_i,
            MILP)
    #3.6
    (alpha_u_mu, alpha_v, delta_alpha_u_mu_a, delta_alpha_v_a, betaNode_u_ePrime_mu, betaEdge_u_e_mu_plus,
     betaEdge_u_e_mu_mins, na_e_a, naInt_a, naEx_a, na_a, delta_atm_i, Mass, msLine, MILP) = assigning_chemical_elements_and_valence_condition(Lambda,  #dict,A[element:code]
            alpha_r_phi, #dict
            valex_F_phi,#dict
            eledeg_F_phi,#dict
            n_a_phi,# dict
            val_a,#dict
            mass_star_a,#dict
            M_ms, #large number
            naInt_LB_a,#dict,{a:xx}
            naInt_UB_a,#dict,{a:xx}
            naEx_LB_a,#dict
            naEx_UB_a,#dict
            n_LB,
            n_UB,
            na_LB_a,
            na_UB_a,
            F_t,
            F_u,
            Xi_u,
            Vo,
            Vo_bar,
            Eo,
            Eo_u,
            Eo_bar_u,
            delta_F_u_mu_phi,
            delta_F_v_phi,
            xNode_u_ePrime_mu,
            xEdge_u_e_v,
            x_u_ksi,
            beta_e,
            beta_u_i,
            fc_e_phi,
            fc_phi,
            n_G,
            MILP)
    #3.7
    delta_ac_u_v_gamma, delta_ac_e_gamma , acInt_gamma ,MILP = desriptors_for_the_number_of_ac(Lambda,
            gammaInt_ac,
            acInt_LB,
            acInt_UB,
            Vo,
            E_T,
            xNode_u_ePrime_mu,
            xEdge_u_e_v,
            e_u_i,
            beta_u_i,
            alpha_u_mu,
            alpha_v,
            beta_e,
            Eo_bar,
            Eo,
            MILP)
    #3.8
    delta_ec_u_v_tau, delta_ec_e_tau, ecInt_tau, MILP = descriptor_for_the_number_of_ec(
            gammaInt_ec,
            gammaInt_ac,
            ecInt_LB,
            ecInt_UB,
            delta_ac_u_v_gamma,
            delta_ac_e_gamma,
            delta_Deg_u_mu_d,
            delta_Deg_v_d,
            xNode_u_ePrime_mu,
            xEdge_u_e_v,
            Vo,
            E_T,
            Eo_bar,
            Eo,
            e_u_i,
            MILP)

    #------inverse problem-------#
    ### Building connection between descriptors and variables ###
    descriptors, num_fv, max_dcp, min_dcp = prepare_fv(
        original_data_file,
        Xi_T,
        cc_ksi,
        Lambda_int,
        Lambda_ex,
        gammaInt_ec,
        gamma_lf_ac,
        index_set,
        rank,
        n_G,
        n_int,
        msLine,
        deg_d,degInt_d,
        bd_m,
        naInt_a, naEx_a,
        ecInt_tau,
        fc_phi,
        ac_lf_gamma)

    ### x_hat is the normalization solution ###
    MILP, x_hat = add_constraints_nor_std_fv(MILP,
        num_fv,
        descriptors,
        max_dcp,
        min_dcp,
        eps)
    ### Normalizing the target value###
    y_min, y_max = get_value(value_file)
    target_value_lb = (target_value_lb - y_min) / (y_max - y_min)
    target_value_ub = (target_value_ub - y_min) / (y_max - y_min)

    ### add constrains of prediction function ###
    fp = open(LR_file)  # weight
    LR = lr_inverter.read_LR(fp)
    weight_var, y = LR.build_weight_var()
    LR.build_constraints(MILP, target_value_lb, target_value_ub)  # add prediction function to constrains
    fp.close()
    MILP = add_constraints__LR(MILP,
                            x_hat,
                            num_fv,
                            LR,
                            prop = "def")

    MILP.writeLP("Problem.lp")
    initial_end = time.time()
    print("Initializing Time:", "{:.3f}".format(initial_end - start))

    #----some information----#
    num_vars = len(MILP.variables())
    num_ints = len([var for var in MILP.variables() if var.cat == pulp.LpInteger])
    bins = [v.name for v in MILP.variables()
            if (v.cat == pulp.LpBinary or
                (v.cat == "Integer" and
                 v.upBound and v.lowBound != None and
                 round(v.upBound - v.lowBound) == 1))]

    num_constraints = len(
        [c for c in MILP.constraints.items()])

    print("Number of variables:", num_vars)
    print(" - Integer :", num_ints)
    print(" - Binary  :", len(bins))
    print("Number of constraints:", num_constraints)

    #------solve MILP--------#
    if solver_type == 1:
        if CPLEX_TIMELIMIT > 0:
            CPLEX = pulp.CPLEX(path=CPLEX_path,
                               msg=CPLEX_msg,
                               timeLimit=CPLEX_TIMELIMIT)

        else:
            CPLEX = pulp.CPLEX(path=CPLEX_path,
                               msg=CPLEX_msg)

        MILP.solve(CPLEX)
    else:
        MILP.solve()

    if pulp.LpStatus[MILP.status] == "Optimal":
        output_status = "Feasible"
    else:
        output_status = pulp.LpStatus[MILP.status]

    if output_status == "Feasible":
        with open(value_of_var, "w") as f:
            # f.write("######### Feature Vector ############\n")
            # for i in range(1, num_fv):
            #     f.write(stringoutput[i] + str(y[(1, i)].value()) + "\n")
            # f.write("\n\n\n")
            # f.write("#####################################\n")

            for var in MILP.variables():
                if type(var) is dict:
                    for x in var:
                        if var[x].value() is None:
                            pass
                        elif abs(var[x].value()) > 0.0000001:
                            f.write(f"{var[x].name}: {var[x].value()}\n")
                elif var.value() is None:
                    pass
                elif abs(var.value()) > 0.0000001:
                    f.write(f"{var.name}: {var.value()}\n")

            f.write("\n")

        # -----
        print("Status:", output_status)
        print("Solving Time:", "{:.3f}".format(time.time() - initial_end))

        y_star = y.value()
        y_star_scaled = y_star * (y_max - y_min) + y_min

        print("MILP y* (scaled):", "{:.3f}".format(y_star_scaled))
        print(f"n_G : {n_G.value()}, n_int : {n_int.value()}")

    else:
        print("Status:", pulp.LpStatus[MILP.status])


    if pulp.LpStatus[MILP.status] == "Optimal":

        output_sdf_file(Lambda,
                    F_t,
                    F_u,
                    Vo,
                    Vo_bar,
                    Eo_u,
                    Eo_bar_u,
                    Eo,
                    Eo_bar,

                    # variable
                    xEdge_u_e_v,
                    xNode_u_ePrime_mu,
                    e_u_i,
                    beta_e,
                    beta_u_i,
                    delta_F_u_mu_phi,
                    delta_F_v_phi,
                    alpha_u_mu,
                    alpha_v,

                    output_path,
                    instance_name)


if __name__ == "__main__":
    main(sys.argv)
